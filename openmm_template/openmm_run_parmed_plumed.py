"""
Generated by CHARMM-GUI (http://www.charmm-gui.org)
Modified by akognole@outerbanks.umaryland.edu for use in GCMC-MD
"""

from __future__ import print_function
import argparse
import sys
import os

from omm_readinputs import *
from omm_readparams import *
from omm_vfswitch import *
from omm_barostat import *
from omm_restraints import *
from omm_rewrap import *

from simtk.unit import *
from simtk.openmm import *
from simtk.openmm.app import *

# ParmEd Imports
from parmed import load_file
from parmed.openmm.reporters import NetCDFReporter
from parmed import unit as u

# Plumed plugin imports
from openmmplumed import PlumedForce

parser = argparse.ArgumentParser()
parser.add_argument('-i', dest='inpfile', help='Input parameter file', required=True)
parser.add_argument('-p', dest='psffile', help='Input GROMACS TOP file', required=True)
parser.add_argument('-c', dest='crdfile', help='Input GROMACS GRO file', required=True)
parser.add_argument('-irst', metavar='RSTFILE', dest='irst', help='Input restart file (optional)', default=None)
parser.add_argument('-ichk', metavar='CHKFILE', dest='ichk', help='Input checkpoint file (optional)', default=None)
parser.add_argument('-orst', metavar='RSTFILE', dest='orst', help='Output restart file (optional)', default=None)
parser.add_argument('-ochk', metavar='CHKFILE', dest='ochk', help='Output checkpoint file (optional)', default=None)
parser.add_argument('-odcd', metavar='DCDFILE', dest='odcd', help='Output trajectory file (optional)', default=None)
parser.add_argument('-rewrap', dest='rewrap', help='Re-wrap the coordinates in a molecular basis (optional)', action='store_true', default=False)
args = parser.parse_args()

# Load parameters
print("Loading parameters...")
inputs = read_inputs(args.inpfile)
top = load_file(args.psffile)
gro = load_file(args.crdfile)

# Transfer the unit cell information from the GRO file to the top object
top.box = gro.box[:]

# Build system
print("Building system...")
system = top.createSystem(nonbondedMethod=inputs.coulomb,
                          nonbondedCutoff=inputs.r_off*nanometers,
                          constraints=inputs.cons,
                          ewaldErrorTolerance=inputs.ewald_Tol)

if inputs.vdw == 'Force-switch': system = vfswitch(system, top, inputs)
if inputs.pcouple == 'yes':      system = barostat(system, inputs)
if inputs.rest == 'yes':
    system = restraints(system, gro, inputs)
else:
    # Using PLUMED to add centerofmass restraint
    # Plumed plugin imports
    from openmmplumed import PlumedForce
    ## Define Plumed parameters and force
    script = """
    a0: FIXEDATOM AT=<CENTEROFMASS>
    b0: COM ATOMS=1-<NUMBEROFRNAATOMS> NOPBC
    pb: POSITION ATOM=b0 NOPBC
    d0: DISTANCE ATOMS=a0,b0
    r0: RESTRAINT ARG=d0 AT=0 KAPPA=40
    PRINT ARG=pb.x,pb.y,pb.z,d0,r0.bias STRIDE=100 FILE=center.dat """
    system.addForce(PlumedForce(script))
    
integrator = LangevinIntegrator(inputs.temp*kelvin, inputs.fric_coeff/picosecond, inputs.dt*picoseconds)

# Set platform
print("Setting platform...")
platform = Platform.getPlatformByName('CUDA')
prop = dict(CudaPrecision='single')

# Build simulation context
print("Building simulation context...")
simulation = Simulation(top.topology, system, integrator, platform, prop)
simulation.context.setPositions(gro.positions)

if args.irst:
    with open(args.irst, 'r') as f:
        simulation.context.setState(XmlSerializer.deserialize(f.read()))
if args.ichk:
    with open(args.ichk, 'rb') as f:
        simulation.context.loadCheckpoint(f.read())

# Re-wrap
if args.rewrap:
    print("\nRe-wrapping the simulation")
    simulation = rewrap(simulation)

# Calculate initial system energy
print("\nInitial system energy")
print(simulation.context.getState(getEnergy=True).getPotentialEnergy())

# Energy minimization
if inputs.mini_nstep > 0:
    print("\nEnergy minimization: %s steps" % inputs.mini_nstep)
    simulation.minimizeEnergy(tolerance=inputs.mini_Tol*kilojoule/mole, maxIterations=inputs.mini_nstep)
    print(simulation.context.getState(getEnergy=True).getPotentialEnergy())

# Generate initial velocities
if inputs.gen_vel == 'yes':
    print("\nGenerate initial velocities")
    if inputs.gen_seed:
        simulation.context.setVelocitiesToTemperature(inputs.gen_temp, inputs.gen_seed)
    else:
        simulation.context.setVelocitiesToTemperature(inputs.gen_temp)

# Production
if inputs.nstep > 0:
    print("\nMD run: %s steps" % inputs.nstep)
    if inputs.nstdcd > 0:
        if not args.odcd: args.odcd = 'output.dcd'
        simulation.reporters.append(DCDReporter(args.odcd, inputs.nstdcd))
    simulation.reporters.append(
        StateDataReporter(sys.stdout, inputs.nstout, step=True, time=True, potentialEnergy=True, temperature=True, volume=True, progress=True,
                          remainingTime=True, speed=True, totalSteps=inputs.nstep, separator='\t')
    )
    simulation.reporters.append(PDBReporter('output.pdb', inputs.nstep))
    simulation.step(inputs.nstep)

# Write restart file
if not (args.orst or args.ochk): args.orst = 'output.rst'
if args.orst:
    state = simulation.context.getState( getPositions=True, getVelocities=True )
    with open(args.orst, 'w') as f:
        f.write(XmlSerializer.serialize(state))
if args.ochk:
    with open(args.ochk, 'wb') as f:
        f.write(simulation.context.createCheckpoint())

